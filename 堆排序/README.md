# 堆排序

### 堆与堆排序
堆是一个完全二叉树，它分为大顶堆（子节点比父节点大）和小顶堆（父结点比子节点小）。我们经常将堆用于输出最大（或最小的N个值）。
###### 构建堆
假设有N个数据，首先开辟内存空间。根节点的位置为0.子节点的位置为1，2.定义一个shift函数来调整数据。它的作用是：将数据与（n-1）/2位置的数据（新数据的父节点）比较，如果比父节点大那么就交换，继续比较，直到它比父节点小/。

###### 堆排序
将堆顶数据弹出（它将会是最大或者是最小的数据，然后将最后一个节点的值放到堆顶，进行一次构建，与子节点比较交换，然后继续比较交换）。

> 堆实际上是一棵完全二叉树， 利用大顶堆(小顶堆)堆顶记录的是最大关键字(最小关键字)这一特性，使得每次从无序中选择最大记录(最小记录)变得简单。
 - 将初始待排序关键字序列(R1,R2....Rn)构建成大顶堆，此堆为初始的无序区；
 - 将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,......Rn-1)和新的有序区(Rn),且满足R[1,2...n-1]<=R[n]; 
 - 由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,......Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2....Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。

### 流程
 1. 初始化堆：将R[1..n]构造为堆；
 2. 将当前无序区的堆顶元素R[1]同该区间的最后一个记录交换，然后将新的无序区调整为新的堆。

